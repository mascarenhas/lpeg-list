Support for matching lists with LPEG
(http://www.inf.puc-rio.br/~roberto/lpeg), like OMeta does.

Is working, but I consider it in alpha, I still have to think on how I
want list matching to work exactly, and how its syntax should be for
RE patterns.

Simple captures in lists are working, the examples below show how they
operate (produce a slice of the list, basically), but I haven't thought
through on how to do substitution and dynamic matches (dynamic matches do
work right now, after a fashion, but it looks like an ugly hack).

Oh, and no verifier, but the compiler is generating correct code so this
is not such a big deal. :-)

It's backward compatible with LPEG 0.9, but this may change...

Some examples (there's a simple expression compiler and evaluator at the end):

--------------------------
re = require "re"

p = re.compile[[ {{ "one", {"two"}, "three" }} ]]

assert(p:match{ "one" , "two" ,"three" })

p = re.compile[[
    {{ "one", { "two", ({{ ("foo""bar"*), "bar" }} / {{ "baz", "boo" }})* },
     "three" }}
]]

assert(p:match{ "one", "two", "three" } == "two")
assert(#{ p:match{ "one", "two", "three" } } == 1)
assert(#{ p:match{ "one", "two", { "foo", "bar" }, { "baz", "boo" }, "three" }} == 3)
local _, t = p:match{ "one", "two", { "foobarbarbar", "bar" }, { "baz", "boo" },
		"three" }
assert(t[1] == "foobarbarbar")
assert(#{ p:match{ "one", "two", { "foobarbar", "bar" }, { "baz", "boo" },
		   "three" } } == 3)


p = re.compile([[ {{ "add", ({.+}), ({.+}) }} -> add ]], { add = function (x, y)
								    return x+y
								 end })
assert(p:match{ "add", 2, 3 })
assert(p:match{ "add", 72, 3 } == 75)
assert(p:match{ "add", 72.5, 3 } == 75.5)
assert(not p:match{ "sub", 72, 3 })
assert(not p:match{ "add", 3 })

p = re.compile[[ {{ "foo", { "bar", (!"baz" .+)*, "baz" }, "boo" }} ]]

assert(select(4, p:match{ "foo", "bar", "one", "two", "three", "baz", "boo" }) == "three")
assert(#{ p:match{ "foo", "bar", "one", "two", "three", "baz", "boo" } } == 5)
assert(select(5, p:match{ "foo", "bar", "one", "two", "three", "baz", "boo" }) == "baz")
assert(select(2, p:match{ "foo", "bar", "baz", "boo" }) == "baz")
assert(#{ p:match{ "foo", "bar", "baz", "boo" } } == 2)

p = re.compile[[ {{ "foo", "bar", { (!"baz" .+)* }, "baz" , "boo" }} ]]

assert(#{ p:match{ "foo", "bar", "one", "two", "three", "baz", "boo" } } == 3)
assert(select(3, p:match{ "foo", "bar", "one", "two", "three", "baz", "boo" }) == "three")
assert(#{ p:match{ "foo", "bar", "baz", "boo" } } == 0)

p = re.compile([[
	       exp <- {{ "add", <exp>, <exp> }} -> add
                    / {{ "sub", <exp>, <exp> }} -> sub
		    / {{ "mul", <exp>, <exp> }} -> mul
		    / {{ "div", <exp>, <exp> }} -> div
		    / {.}
    ]], { add = function (x, y) return x + y end, 
          sub = function (x, y) return x - y end,
          mul = function (x, y) return x * y end,
          div = function (x, y) return x / y end, })

assert(p:match{ "add", { "div", 8, 2 }, 3 } == 7)
assert(p:match{ "sub", { "div", 8, { "add", 2, 2 } }, 3 } == -1)

p = re.compile([[ exp <- {{ (.+ -> ops), <exp>, <exp> }} -> eval / {{ "num", {.} }} ]], 
	       { ops = { add = function (x, y) return x + y end, 
                         sub = function (x, y) return x - y end,
                         mul = function (x, y) return x * y end,
                         div = function (x, y) return x / y end, },
                 eval = function (op, x, y) return op(x, y) end })

assert(p:match{ "add", { "div", { "num", 8 }, { "num", 2 } }, { "num", 3 }} == 7)
assert(p:match{ "sub", { "div", { "num", 8 }, { "add", { "num", 2 }, { "num", 2 } } }, 
		{ "num", 3  } } == -1)

parser = re.compile([[
  exp <- <add>
  add <- (<mul>:x <aop>:op <add>:y) -> { op, x, y } / <mul>
  mul <- (<prim>:x <mop>:op <mul>:y) -> { op, x, y } / <prim>
  prim <- (%s "(" %s <exp> %s ")" %s) / (%s %num -> tonumber %s):n -> { "num", n }
  aop <- (%s "+" -> "add" %s) / (%s "-" -> "sub" %s)
  mop <- (%s "*" -> "mul" %s) / (%s "/" -> "div" %s)
]], { s = m.S(" \n\t")^0, num = m.C(lpeg.P"-"^-1 * lpeg.R("09")^1), tonumber = tonumber })

assert(p:match(parser:match("8/2+3")) == 7)
assert(p:match(parser:match("8 / (2 + 2) - 3")) == -1)
---------------------------

Use LuaRocks (http://luarocks.org) and the provided .rockspec file to
compile and install. No docs yet, check the test suite list.lua for
more examples.
